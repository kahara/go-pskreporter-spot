package spot

import (
	"encoding/binary"
	"time"
)

// See https://pskreporter.info/pskdev.html

const (
	HeaderLength = 16
)

var (
	Header               = []byte{0x00, 0x0A} // "Version" in RFC 5101
	ReceiverRecordHeader = []byte{0x99, 0x92} // "Set ID" in RFC 5101(?)
	SenderRecordHeader   = []byte{0x99, 0x93}

	// TODO figure out what is the "theoretical" maximum size of receiver record,
	// TODO for making the decision to get an item from the queue

	ReceiverDescriptor_CallsignLocatorSoftware = []byte{
		0x00, 0x03, 0x00, 0x24, 0x99, 0x92, 0x00, 0x03, 0x00, 0x00,
		0x80, 0x02, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x04, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x08, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x00, 0x00,
	}
	ReceiverDescriptor_CallsignLocatorSoftwareAntenna = []byte{
		0x00, 0x03, 0x00, 0x2C, 0x99, 0x92, 0x00, 0x04, 0x00, 0x00,
		0x80, 0x02, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x04, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x08, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x09, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x00, 0x00,
	}
	SenderDescriptor_CallsignFrequencyModeSourceFlowstart = []byte{
		0x00, 0x02, 0x00, 0x2C, 0x99, 0x93, 0x00, 0x05,
		0x80, 0x01, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x05, 0x00, 0x04, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x0A, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x0B, 0x00, 0x01, 0x00, 0x00, 0x76, 0x8F,
		0x00, 0x96, 0x00, 0x04,
	}
	SenderDescriptor_CallsignFrequencyModeSourceLocatorFlowstart = []byte{
		0x00, 0x02, 0x00, 0x34, 0x99, 0x93, 0x00, 0x06,
		0x80, 0x01, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x05, 0x00, 0x04, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x0A, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x0B, 0x00, 0x01, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x00, 0x96, 0x00, 0x04,
	}
	SenderDescriptor_CallsignFrequencySNRIMDModeSourceFlowstart = []byte{
		0x00, 0x02, 0x00, 0x3C, 0x99, 0x93, 0x00, 0x07,
		0x80, 0x01, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x05, 0x00, 0x04, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x06, 0x00, 0x01, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x07, 0x00, 0x01, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x0A, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x0B, 0x00, 0x01, 0x00, 0x00, 0x76, 0x8F,
		0x00, 0x96, 0x00, 0x04,
	}
	SenderDescriptor_CallsignFrequencySNRIMDModeSourceLocatorFlowstart = []byte{
		0x00, 0x02, 0x00, 0x44, 0x99, 0x93, 0x00, 0x08,
		0x80, 0x01, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x05, 0x00, 0x04, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x06, 0x00, 0x01, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x07, 0x00, 0x01, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x0A, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x0B, 0x00, 0x01, 0x00, 0x00, 0x76, 0x8F,
		0x80, 0x03, 0xFF, 0xFF, 0x00, 0x00, 0x76, 0x8F,
		0x00, 0x96, 0x00, 0x04,
	}
)

func IPFIX(sequenceNumber uint32, observationDomain uint32, descriptors []byte, records []byte) []byte {
	var (
		ipfix  []byte
		header [16]byte
	)

	// Construct an IPFIX header with message length, timestamp, sequence number, and observation domain
	header[0] = Header[0]
	header[1] = Header[1]
	binary.BigEndian.PutUint16(header[2:], uint16(HeaderLength+len(descriptors)+len(records)))
	binary.BigEndian.PutUint32(header[4:], uint32(time.Now().UTC().Unix()))
	binary.BigEndian.PutUint32(header[8:], sequenceNumber)
	binary.BigEndian.PutUint32(header[12:], observationDomain)

	// Concatenate everything
	ipfix = append(ipfix, header[:]...)   // Header is an array...
	ipfix = append(ipfix, descriptors...) // ...and these are slices
	ipfix = append(ipfix, records...)

	return ipfix
}

func IPFIXDescriptors(spotter *Spotter) []byte {
	if spotter.antennaInformation == "" {
		return ReceiverDescriptor_CallsignLocatorSoftware
	} else {
		return ReceiverDescriptor_CallsignLocatorSoftwareAntenna
	}
}

func IPFIXRecords(spotter *Spotter, spent int) []byte {
	var (
		records          []byte
		payloadBytesLeft = spotter.maxPayloadBytes - spent - 3 - 3 // Leave margin for paddings, too
		header           [4]byte
		record           []byte
		padding          = 0
	)

	// Receiver record; callsign, locator, decoderSoftware, (optionally) antennaInformation
	// FIXME limit the strings' lengths
	record = append(record, uint8(len(spotter.receiver.Callsign)))
	record = append(record, []byte(spotter.receiver.Callsign)...)
	record = append(record, uint8(len(spotter.receiver.Locator)))
	record = append(record, []byte(spotter.receiver.Locator)...)
	record = append(record, uint8(len(spotter.decoderSoftware)))
	record = append(record, []byte(spotter.decoderSoftware)...)
	if spotter.antennaInformation != "" {
		record = append(record, uint8(len(spotter.antennaInformation)))
		record = append(record, []byte(spotter.antennaInformation)...)
	}

	header[0] = ReceiverRecordHeader[0]
	header[1] = ReceiverRecordHeader[1]
	binary.BigEndian.PutUint16(header[2:], uint16(len(record)))
	records = append(records, header[:]...)
	records = append(records, record...)

	// Add padding for 4-byte alignment
	padding = 4 - (len(records) % 4)
	for i := 0; i < padding; i++ {
		records = append(records, 0)
	}

	payloadBytesLeft = payloadBytesLeft - len(records)

	// Sender records
	record = []byte{}

	header[0] = SenderRecordHeader[0]
	header[1] = SenderRecordHeader[1]
	binary.BigEndian.PutUint16(header[2:], uint16(0)) // XXX encode the length
	records = append(records, header[:]...)

	// Pad the sender records, too
	padding = 4 - (len(records) % 4)
	for i := 0; i < padding; i++ {
		records = append(records, 0)
	}

	return records
}
